{"name":"Simplefuture","tagline":"Enhanced Non Blocking Futures for Java","body":"SimpleFuture [![Build Status](https://travis-ci.org/srideepprasad/SimpleFuture.png?branch=master)](https://travis-ci.org/srideepprasad/SimpleFuture)\r\n======\r\n####The Future's simple - once you \"un-block\" it !\r\n\r\nSimple library to demonstrate 'non-blocking' futures (background async tasks) in Java. No need of \"blocking\" Future.get() anymore - instead rely on dynamic notification for completion/cancellation/failure.\r\nDemonstrates possible techniques by which fancy Future abstractions could be provided - as is done now in Scala for example. At the heart of it, we just need a way to tap into the Future/Executor framework to get dynamic notifications on task execution events.\r\nThe core JDK provides all that's necessary for non-blocking Futures - unfortunately. there's no readymade implementation (Java 1.5-1.7), giving rise to the misconception that these are not possible in core Java.\r\n\r\nHaving said that, Java 8 includes the CompletableFuture class which is a huge step forward, and may be worth a look.\r\n\r\n#####Usage\r\n***\r\nUsage is straightfoward, and self explanatory (if you have used Executors/Futures before especially)\r\n\r\n* __Step 1 - Create a Task Definition__\r\n\r\nCreate an AsyncTaskDef for a standard Java callable task\r\n\r\n```\r\n        AsyncTaskDef<Double> taskDef = AsyncTaskDef.forTask(callableTask);\r\n```\r\nBy default, an instance of DefaultExecutor is used, which provides a max thread pool of 20 threads. If required, you could use any other standard java executor as well\r\n\r\n```\r\n        AsyncTaskDef<Double> taskDef = AsyncTaskDef.forTask(callableTask,someExecutor);\r\n```\r\nThe \"callableTask\" variable is a standard java interface, used to define background jobs - one may be created as follows:\r\n```\r\n            Callable<Double> callableTask = new Callable<Double>() {\r\n                @Override public Double call() throws Exception {\r\n                    //Some complex computation!\r\n                    return someValue;\r\n                };\r\n            };\r\n```\r\nThis interface is generified, so you could define what type the callable task would return.\r\n\r\n* __Step 2 (Optional) - Setup async notification callbacks__\r\n\r\nSetup a TaskResultHandler which would receive callback notifications (on task completion/cancellation/exception). These will be executed on the same thread which executed the callable task\r\n\r\n```\r\n        taskDef.resultTo(new TaskResultHandler<Double>() {\r\n            @Override public void onComplete(Double result) {\r\n                //Handle result\r\n            }\r\n\r\n            @Override public void onCancel() {\r\n                //Handle cancellation\r\n            }\r\n\r\n            @Override public void onException(Exception ex) {\r\n                //Handle exception\r\n            }\r\n        });\r\n```\r\nIf no TaskResultHandler is defined, a NoOpTaskResultHandler instance is used internally (does nothing).\r\nAlternately, you could also extend the NoOpTaskResultHandler and only override the methods one is interested in\r\n\r\n* __Step 3 - Execution__\r\n\r\nYou are ready to go ! Just call submit()\r\n```\r\n  Future<Double> task = taskDef.submit();\r\n```\r\nYou now have a Future instance, which will notify the TaskResultHandler via callbacks on completion/cancellation/exception of the background task..\r\nNo need of Future.get() - though you can still call it if needed! This Future implementation (AsyncTask class) follows standard JDK specs, and therefore could easily plugged in anywhere.\r\n\r\n* __Step 4 - (Optional) Obtaining the Executor instance__\r\n\r\nIf you don't provide an Executor to AsyncTaskDef.forTask(), then the default Executor returned via DefaultExecutor.getInstance() is used. This executor implements a fixed thread pool of 20 threads. If you need an instance of the executor running a Future, you may do as follows:\r\n```\r\n  AsyncTask<Double> task = taskDef.submit();\r\n```\r\nInstead of:\r\n```\r\n  Future<Double> task = taskDef.submit();\r\n```\r\nAsyncTask is the class implementing the Future interface - and has an additional method getExecutor(), which returns the executor executing the task. This method may be needed if you don't provide an Executor while creating the AsyncTaskDef, and still want to control the underlying thread pool.\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}